#!/usr/bin/env node
/**
 * ARK Code Lattice Manager
 * Capability-based knowledge graph for code generation
 */

const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const LATTICE_DIR = process.env.ARK_LATTICE_DIR || path.join(process.env.HOME, 'ark', 'code-lattice');
const DB_PATH = path.join(LATTICE_DIR, 'lattice.db');

class CodeLattice {
    constructor(dbPath = DB_PATH) {
        this.db = new sqlite3.Database(dbPath);
    }

    /**
     * Add a new capability node
     */
    addNode(node) {
        return new Promise((resolve, reject) => {
            const {
                id = this.generateId(node),
                type,
                language = null,
                category = null,
                value,
                capabilities = [],
                dependencies = [],
                examples = [],
                content = null,
                linked_agents = []
            } = node;

            const sql = `
                INSERT OR REPLACE INTO nodes 
                (id, type, language, category, value, capabilities, dependencies, examples, content, linked_agents)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `;

            this.db.run(sql, [
                id,
                type,
                language,
                category,
                value,
                JSON.stringify(capabilities),
                JSON.stringify(dependencies),
                JSON.stringify(examples),
                content,
                JSON.stringify(linked_agents)
            ], (err) => {
                if (err) reject(err);
                else resolve(id);
            });
        });
    }

    /**
     * Query nodes by criteria
     */
    queryNodes(criteria, limit = null) {
        return new Promise((resolve, reject) => {
            let sql = 'SELECT * FROM nodes WHERE 1=1';
            const params = [];

            if (criteria.type) {
                sql += ' AND type = ?';
                params.push(criteria.type);
            }
            if (criteria.language) {
                sql += ' AND language = ?';
                params.push(criteria.language);
            }
            if (criteria.category) {
                sql += ' AND category = ?';
                params.push(criteria.category);
            }
            if (criteria.search) {
                sql += ' AND (value LIKE ? OR id LIKE ?)';
                params.push(`%${criteria.search}%`, `%${criteria.search}%`);
            }
            if (criteria.capability) {
                sql += ' AND (capabilities LIKE ? OR value LIKE ?)';
                params.push(`%${criteria.capability}%`, `%${criteria.capability}%`);
            }

            sql += ' ORDER BY usage_count DESC, success_rate DESC';
            
            if (limit) {
                sql += ' LIMIT ?';
                params.push(limit);
            }

            this.db.all(sql, params, (err, rows) => {
                if (err) reject(err);
                else {
                    // Parse JSON fields
                    rows.forEach(row => {
                        row.capabilities = JSON.parse(row.capabilities || '[]');
                        row.dependencies = JSON.parse(row.dependencies || '[]');
                        row.examples = JSON.parse(row.examples || '[]');
                        row.linked_agents = JSON.parse(row.linked_agents || '[]');
                    });
                    resolve(rows);
                }
            });
        });
    }

    /**
     * Generate code from nodes
     */
    async generateCode(requirements, options = {}) {
        // Handle both array of requirements and string
        const reqArray = Array.isArray(requirements) ? requirements : [requirements];
        const request = reqArray.join(' ');
        const language = options.language || null;
        
        console.log(`ðŸ§¬ Generating code for: ${request}`);
        if (language) {
            console.log(`   Target language: ${language}`);
        }
        
        // Parse request to determine needed nodes
        const nodes = await this.findNodesForRequest(request, language);
        
        if (nodes.length === 0) {
            throw new Error('No matching nodes found for request');
        }

        console.log(`ðŸ“¦ Found ${nodes.length} relevant nodes`);
        
        // Simple code generation - just concatenate templates
        let code = '';
        nodes.forEach(node => {
            if (node.content) {
                code += node.content + '\n\n';
            }
        });
        
        // If no content found, generate a basic template
        if (!code.trim()) {
            code = `// Generated by ARK Code Lattice\n// Request: ${request}\n\n`;
            code += `// Matched nodes:\n`;
            nodes.forEach(node => {
                code += `// - ${node.id}: ${node.value}\n`;
            });
        }

        return {
            code,
            nodes,
            request
        };
    }

    /**
     * Find nodes that match a request
     */
    async findNodesForRequest(request, targetLanguage = null) {
        const keywords = request.toLowerCase().split(' ');
        const nodes = [];

        // If target language specified, search by that
        if (targetLanguage) {
            const langNodes = await this.queryNodes({ language: targetLanguage }, 10);
            nodes.push(...langNodes);
        } else {
            // Search by language keywords
            for (const lang of ['c', 'c++', 'java', 'typescript', 'javascript', 'python', 'go', 'rust', 'kotlin', 'swift']) {
                if (keywords.includes(lang) || keywords.includes(lang.replace('+', 'plus'))) {
                    const langNodes = await this.queryNodes({ language: lang }, 5);
                    nodes.push(...langNodes);
                }
            }
        }

        // Search by pattern
        for (const pattern of ['mvc', 'factory', 'singleton', 'observer', 'rest', 'api', 'microservice']) {
            if (keywords.includes(pattern)) {
                const patternNodes = await this.queryNodes({ 
                    type: 'pattern_node',
                    search: pattern 
                }, 3);
                nodes.push(...patternNodes);
            }
        }

        // Search by component type
        for (const comp of ['api', 'cli', 'web', 'scraper', 'service', 'hello', 'server', 'client']) {
            if (keywords.includes(comp)) {
                const compNodes = await this.queryNodes({ search: comp }, 3);
                nodes.push(...compNodes);
            }
        }

        // If no nodes found, try general search
        if (nodes.length === 0) {
            const searchNodes = await this.queryNodes({ search: request }, 5);
            nodes.push(...searchNodes);
        }

        // Deduplicate
        return Array.from(new Map(nodes.map(n => [n.id, n])).values());
    }

    /**
     * Assemble code from nodes
     */
    async assembleCode(nodes, outputPath) {
        const files = [];

        for (const node of nodes) {
            if (node.content) {
                // Determine filename from node type and examples
                let filename = 'main.c';
                if (node.examples && node.examples.length > 0) {
                    filename = node.examples[0];
                } else if (node.language) {
                    const extensions = {
                        'c': '.c',
                        'c++': '.cpp',
                        'java': '.java',
                        'typescript': '.ts',
                        'python': '.py'
                    };
                    filename = `${node.id}${extensions[node.language] || '.txt'}`;
                }

                const filepath = path.join(outputPath, filename);
                fs.writeFileSync(filepath, node.content);
                files.push(filepath);
                
                console.log(`  âœ“ Generated: ${filename}`);
            }
        }

        // Generate README
        const readme = this.generateReadme(nodes);
        const readmePath = path.join(outputPath, 'README.md');
        fs.writeFileSync(readmePath, readme);
        files.push(readmePath);

        return files;
    }

    /**
     * Generate README for generated project
     */
    generateReadme(nodes) {
        let readme = '# ARK Generated Project\n\n';
        readme += '**Generated by:** ARK Code Lattice System\n';
        readme += `**Date:** ${new Date().toISOString()}\n\n`;
        readme += '## Nodes Used\n\n';
        
        nodes.forEach(node => {
            readme += `### ${node.id}\n`;
            readme += `- **Type:** ${node.type}\n`;
            readme += `- **Description:** ${node.value}\n`;
            if (node.dependencies.length > 0) {
                readme += `- **Dependencies:** ${node.dependencies.join(', ')}\n`;
            }
            readme += '\n';
        });

        readme += '## Building\n\n';
        readme += 'See individual file comments for build instructions.\n';

        return readme;
    }

    /**
     * Log a generation event
     */
    logGeneration(gen) {
        return new Promise((resolve, reject) => {
            const sql = `
                INSERT INTO generations (id, request, nodes_used, output_path, success, build_log)
                VALUES (?, ?, ?, ?, ?, ?)
            `;

            this.db.run(sql, [
                gen.id,
                gen.request,
                JSON.stringify(gen.nodes_used),
                gen.output_path,
                gen.success ? 1 : 0,
                gen.build_log || null
            ], (err) => {
                if (err) reject(err);
                else resolve(gen.id);
            });
        });
    }

    /**
     * Generate unique ID for node or generation
     */
    generateId(data) {
        const str = JSON.stringify(data);
        return 'sha1:' + crypto.createHash('sha1').update(str).digest('hex').substring(0, 16);
    }

    /**
     * Get statistics about the lattice
     */
    getStats() {
        return new Promise((resolve, reject) => {
            const stats = {
                total_nodes: 0,
                languages: [],
                node_types: [],
                categories: []
            };

            // Get total count
            this.db.get('SELECT COUNT(*) as count FROM nodes', (err, row) => {
                if (err) return reject(err);
                stats.total_nodes = row.count;

                // Get language breakdown
                this.db.all(`
                    SELECT language, COUNT(*) as count 
                    FROM nodes 
                    GROUP BY language 
                    ORDER BY count DESC
                `, (err, rows) => {
                    if (err) return reject(err);
                    stats.languages = rows;

                    // Get type breakdown
                    this.db.all(`
                        SELECT type, COUNT(*) as count 
                        FROM nodes 
                        GROUP BY type 
                        ORDER BY count DESC
                    `, (err, rows) => {
                        if (err) return reject(err);
                        stats.node_types = rows;

                        // Get category breakdown
                        this.db.all(`
                            SELECT category, COUNT(*) as count 
                            FROM nodes 
                            WHERE category IS NOT NULL
                            GROUP BY category 
                            ORDER BY count DESC
                        `, (err, rows) => {
                            if (err) return reject(err);
                            stats.categories = rows;
                            resolve(stats);
                        });
                    });
                });
            });
        });
    }

    /**
     * Delete a node by ID
     */
    deleteNode(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM nodes WHERE id = ?', [id], function(err) {
                if (err) reject(err);
                else if (this.changes === 0) reject(new Error('Node not found'));
                else resolve(id);
            });
        });
    }

    close() {
        this.db.close();
    }
}

// CLI Interface
if (require.main === module) {
    const lattice = new CodeLattice();
    const command = process.argv[2];
    const args = process.argv.slice(3);

    (async () => {
        try {
            switch (command) {
                case 'add':
                    const node = JSON.parse(args[0]);
                    const id = await lattice.addNode(node);
                    console.log(`âœ“ Node added: ${id}`);
                    break;

                case 'query':
                    const criteria = JSON.parse(args[0] || '{}');
                    const nodes = await lattice.queryNodes(criteria);
                    console.log(JSON.stringify(nodes, null, 2));
                    break;

                case 'generate':
                    const request = args.join(' ');
                    const result = await lattice.generateCode(request);
                    console.log(`âœ“ Code generated at: ${result.output_path}`);
                    console.log(`Files created: ${result.files.length}`);
                    break;

                case 'stats':
                    const stats = await lattice.getStats();
                    console.log(JSON.stringify(stats, null, 2));
                    break;

                default:
                    console.log('Usage:');
                    console.log('  lattice-manager.js add <json>');
                    console.log('  lattice-manager.js query <criteria-json>');
                    console.log('  lattice-manager.js generate <request>');
                    console.log('  lattice-manager.js stats');
            }
        } catch (error) {
            console.error('Error:', error.message);
            process.exit(1);
        } finally {
            lattice.close();
        }
    })();
}

module.exports = CodeLattice;
