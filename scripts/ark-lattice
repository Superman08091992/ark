#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ark-lattice - ARK Federation Management CLI

Command-line interface for managing ARK federation:
- Start/stop federation services
- Discover and manage peers
- Configure trust tiers
- Monitor synchronization

Usage:
    ark-lattice federation start
    ark-lattice federation discover
    ark-lattice federation add-peer <url>
    ark-lattice federation auto-sync --start
    ark-lattice federation status
    ark-lattice peers list
    ark-lattice peers trust-tier <peer-id> <tier>
"""

import asyncio
import sys
import os
import json
import argparse
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from federation.federation_core import (
    FederationNode,
    get_federation_node,
    TrustTier,
    PeerManifest
)

try:
    from federation import crypto as ark_crypto
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False


def print_banner():
    """Print ARK lattice banner"""
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                           â•‘
    â•‘        ğŸ•¸ï¸  ARK LATTICE                    â•‘
    â•‘     Federation Management CLI             â•‘
    â•‘                                           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)


async def cmd_federation_start(args):
    """Start federation server"""
    print("ğŸš€ Starting ARK federation server...")
    
    node = get_federation_node()
    manifest = node.get_manifest()
    
    print(f"\nâœ… Federation node initialized:")
    print(f"   Node ID: {manifest.peer_id}")
    print(f"   Name: {manifest.peer_name}")
    print(f"   Address: {manifest.address}:{manifest.port}")
    print(f"   Capabilities: {', '.join(manifest.capabilities)}")
    
    print(f"\nğŸ”§ Starting services...")
    print("   - Discovery service")
    print("   - Sync service")
    print("   - Heartbeat service")
    
    # Start server (non-blocking for CLI)
    print(f"\nâœ… Federation server running on port {node.listen_port}")
    print(f"   Press Ctrl+C to stop\n")
    
    try:
        await node.start()
    except KeyboardInterrupt:
        print("\n\nğŸ›‘ Stopping federation server...")
        await node.stop()
        print("âœ… Federation server stopped")


async def cmd_federation_discover(args):
    """Discover peers on network"""
    print("ğŸ” Discovering peers on local network...")
    
    node = get_federation_node()
    peers = node.discover_peers(subnet=args.subnet if hasattr(args, 'subnet') else "auto")
    
    if peers:
        print(f"\nâœ… Found {len(peers)} peer(s):\n")
        for peer in peers:
            print(f"   â€¢ {peer.peer_name} ({peer.address}:{peer.port})")
            print(f"     ID: {peer.peer_id}")
            print(f"     Trust: {peer.trust_tier.value}")
            print()
    else:
        print("\n   No peers discovered")
        print("   Make sure other ARK nodes are running on the network\n")


async def cmd_federation_add_peer(args):
    """Add peer manually"""
    if not args.url:
        print("âŒ Error: Peer URL required")
        print("   Usage: ark-lattice federation add-peer <url>")
        print("   Example: ark-lattice federation add-peer http://192.168.1.100:8102")
        return
    
    print(f"â• Adding peer: {args.url}")
    
    # Parse URL
    # Format: http://address:port or https://address:port
    try:
        url = args.url.replace('http://', '').replace('https://', '')
        if ':' in url:
            address, port = url.split(':')
            port = int(port)
        else:
            address = url
            port = 8102
        
        # Create manifest
        manifest = PeerManifest(
            peer_id=f"peer_{address.replace('.', '_')}",
            peer_name=f"ARK Node @ {address}",
            address=address,
            port=port
        )
        
        # Add to federation
        node = get_federation_node()
        trust_tier = TrustTier[args.trust.upper()] if hasattr(args, 'trust') else TrustTier.UNKNOWN
        node.add_peer(manifest, trust_tier)
        
        print(f"âœ… Peer added successfully")
        print(f"   Name: {manifest.peer_name}")
        print(f"   Address: {address}:{port}")
        print(f"   Trust Tier: {trust_tier.value}")
        
    except Exception as e:
        print(f"âŒ Error adding peer: {e}")


async def cmd_federation_auto_sync(args):
    """Start/stop auto-sync"""
    node = get_federation_node()
    
    if args.action == 'start':
        print("ğŸ”„ Starting automatic peer synchronization...")
        
        core_peers = node.list_peers(trust_tier=TrustTier.CORE)
        if not core_peers:
            print("âš ï¸  No CORE-tier peers found")
            print("   Add peers with: ark-lattice federation add-peer <url>")
            print("   Set trust tier: ark-lattice peers trust-tier <peer-id> core")
            return
        
        print(f"\nâœ… Auto-sync enabled for {len(core_peers)} peer(s):")
        for peer in core_peers:
            print(f"   â€¢ {peer.peer_name}")
            await node.sync_knowledge(peer.peer_id, auto=True)
        
        print("\n   Continuous bidirectional knowledge flow active")
        
    elif args.action == 'stop':
        print("ğŸ›‘ Stopping automatic peer synchronization...")
        print("âœ… Auto-sync disabled")


async def cmd_federation_status(args):
    """Show federation status"""
    node = get_federation_node()
    stats = node.get_stats()
    
    print("ğŸ“Š ARK Federation Status")
    print("=" * 50)
    print(f"\nğŸ·ï¸  Node Information:")
    print(f"   ID: {stats['node_id']}")
    print(f"   Name: {stats['node_name']}")
    print(f"   Running: {'âœ… Yes' if stats['running'] else 'âŒ No'}")
    
    print(f"\nğŸ¤ Peer Connections:")
    print(f"   Total: {stats['peers']['total']}")
    print(f"   â€¢ CORE: {stats['peers']['core']}")
    print(f"   â€¢ SANDBOX: {stats['peers']['sandbox']}")
    print(f"   â€¢ EXTERNAL: {stats['peers']['external']}")
    print(f"   â€¢ UNKNOWN: {stats['peers']['unknown']}")
    
    print(f"\nğŸ“¦ Knowledge State:")
    print(f"   Local Packets: {stats['knowledge']['local_packets']}")
    print(f"   Sync Queue: {stats['knowledge']['sync_queue']}")
    print()


async def cmd_peers_list(args):
    """List all peers"""
    node = get_federation_node()
    peers = node.list_peers()
    
    if not peers:
        print("   No peers registered")
        print("   Discover peers: ark-lattice federation discover")
        return
    
    print(f"ğŸ¤ Registered Peers ({len(peers)}):")
    print("=" * 50)
    
    for peer in peers:
        print(f"\n   â€¢ {peer.peer_name}")
        print(f"     ID: {peer.peer_id}")
        print(f"     Address: {peer.address}:{peer.port}")
        print(f"     Trust Tier: {peer.trust_tier.value}")
        print(f"     Capabilities: {', '.join(peer.capabilities)}")
        print(f"     Version: {peer.version}")


async def cmd_peers_trust_tier(args):
    """Set peer trust tier"""
    if not args.peer_id or not args.tier:
        print("âŒ Error: peer-id and tier required")
        print("   Usage: ark-lattice peers trust-tier <peer-id> <tier>")
        print("   Tiers: core, sandbox, external, unknown")
        return
    
    try:
        tier = TrustTier[args.tier.upper()]
        node = get_federation_node()
        node.set_peer_trust_tier(args.peer_id, tier)
        print(f"âœ… Trust tier updated to: {tier.value}")
    except KeyError:
        print(f"âŒ Invalid trust tier: {args.tier}")
        print("   Valid tiers: core, sandbox, external, unknown")


# =====================================================
# Crypto Commands
# =====================================================

async def cmd_crypto_keygen(args):
    """Generate new keypair"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        print("   Install: pip install pynacl")
        return
    
    node_id = args.node_id if hasattr(args, 'node_id') and args.node_id else "ark-primary"
    
    if ark_crypto.keypair_exists(node_id):
        print(f"âš ï¸  Keypair already exists for: {node_id}")
        if not (hasattr(args, 'force') and args.force):
            print("   Use --force to regenerate")
            return
        print("   Regenerating...")
        ark_crypto.delete_keypair(node_id)
    
    print(f"ğŸ” Generating Ed25519 keypair for: {node_id}")
    priv, pub = ark_crypto.generate_keypair(node_id)
    
    pub_hex = ark_crypto.export_public_key(node_id)
    fingerprint = pub_hex[:16] + "..."
    
    print(f"âœ… Keypair generated successfully")
    print(f"\nğŸ“‹ Public Key (share with peers):")
    print(f"   {pub_hex}")
    print(f"\nğŸ”‘ Fingerprint: {fingerprint}")
    print(f"\nğŸ’¾ Keys saved to: keys/{node_id}_*.key")


async def cmd_crypto_list_keys(args):
    """List all keys"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        return
    
    keys = ark_crypto.list_keys()
    
    print("ğŸ” ARK Federation Keys")
    print("=" * 50)
    
    if keys['local']:
        print(f"\nğŸ“ Local Keypairs ({len(keys['local'])}):")
        for node_id in keys['local']:
            fingerprint = ark_crypto.get_key_fingerprint(node_id, is_peer=False)
            print(f"   â€¢ {node_id}")
            print(f"     Fingerprint: {fingerprint}")
    else:
        print("\n   No local keypairs found")
        print("   Generate: ark-lattice crypto keygen")
    
    if keys['peers']:
        print(f"\nğŸ¤ Trusted Peer Keys ({len(keys['peers'])}):")
        for node_id in keys['peers']:
            fingerprint = ark_crypto.get_key_fingerprint(node_id, is_peer=True)
            print(f"   â€¢ {node_id}")
            print(f"     Fingerprint: {fingerprint}")
    else:
        print("\n   No peer keys imported")
        print("   Import: ark-lattice crypto import-key <peer-id> <public-key>")


async def cmd_crypto_export_key(args):
    """Export public key"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        return
    
    node_id = args.node_id if hasattr(args, 'node_id') and args.node_id else "ark-primary"
    
    try:
        pub_hex = ark_crypto.export_public_key(node_id)
        print(f"ğŸ“¤ Public Key for {node_id}:")
        print(f"\n{pub_hex}")
        print(f"\nğŸ’¡ Share this with peers to enable signature verification")
    except FileNotFoundError:
        print(f"âŒ No keypair found for: {node_id}")
        print("   Generate: ark-lattice crypto keygen")


async def cmd_crypto_import_key(args):
    """Import peer public key"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        return
    
    if not args.peer_id or not args.public_key:
        print("âŒ Error: peer-id and public-key required")
        print("   Usage: ark-lattice crypto import-key <peer-id> <public-key-hex>")
        return
    
    try:
        ark_crypto.import_peer_key(args.peer_id, args.public_key)
        fingerprint = ark_crypto.get_key_fingerprint(args.peer_id, is_peer=True)
        print(f"âœ… Imported public key for peer: {args.peer_id}")
        print(f"   Fingerprint: {fingerprint}")
        print(f"\nâš ï¸  Remember to set trust tier:")
        print(f"   ark-lattice peers trust-tier {args.peer_id} core")
    except ValueError as e:
        print(f"âŒ Invalid public key: {e}")


async def cmd_crypto_sign_test(args):
    """Test signing and verification"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        return
    
    node_id = args.node_id if hasattr(args, 'node_id') and args.node_id else "ark-primary"
    
    print(f"ğŸ§ª Testing signing with: {node_id}")
    
    try:
        priv, pub = ark_crypto.load_keypair(node_id)
    except FileNotFoundError:
        print(f"âŒ No keypair found for: {node_id}")
        print("   Generate: ark-lattice crypto keygen")
        return
    
    # Create test packet
    test_packet = {
        "origin_id": node_id,
        "type": "TestPacket",
        "data": {"message": "Hello, ARK Federation!"}
    }
    
    print(f"\nğŸ“¦ Test Packet:")
    print(f"   {test_packet}")
    
    # Sign packet
    envelope = ark_crypto.sign_packet(priv, test_packet)
    print(f"\nâœï¸  Signed packet:")
    print(f"   Signature: {envelope['signature'][:32]}...")
    print(f"   Timestamp: {envelope['timestamp']}")
    
    # Verify with correct key
    valid = ark_crypto.verify_packet(envelope, pub)
    if valid:
        print(f"\nâœ… Signature verified successfully!")
    else:
        print(f"\nâŒ Signature verification failed!")
    
    print(f"\nğŸ’¡ This signature can be verified by any peer with your public key")


async def cmd_crypto_self_test(args):
    """Run crypto self-test"""
    if not CRYPTO_AVAILABLE:
        print("âŒ PyNaCl not installed")
        print("   Install: pip install pynacl")
        return
    
    print("ğŸ§ª Running cryptographic self-test...")
    print()
    
    success = ark_crypto.test_sign_verify()
    
    if success:
        print("\nâœ… All cryptographic tests passed!")
        print("   Ed25519 signing and verification working correctly")
    else:
        print("\nâŒ Crypto self-test failed!")
        print("   Check logs for details")


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="ARK Lattice - Federation Management CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Federation commands
    federation = subparsers.add_parser('federation', help='Federation management')
    federation_sub = federation.add_subparsers(dest='subcommand')
    
    federation_sub.add_parser('start', help='Start federation server')
    
    discover = federation_sub.add_parser('discover', help='Discover peers')
    discover.add_argument('--subnet', help='Subnet to scan (default: auto)')
    
    add_peer = federation_sub.add_parser('add-peer', help='Add peer manually')
    add_peer.add_argument('url', help='Peer URL (e.g., http://192.168.1.100:8102)')
    add_peer.add_argument('--trust', default='unknown', choices=['core', 'sandbox', 'external', 'unknown'])
    
    auto_sync = federation_sub.add_parser('auto-sync', help='Auto-sync control')
    auto_sync.add_argument('action', choices=['start', 'stop'])
    
    federation_sub.add_parser('status', help='Show federation status')
    
    # Peer commands
    peers = subparsers.add_parser('peers', help='Peer management')
    peers_sub = peers.add_subparsers(dest='subcommand')
    
    peers_sub.add_parser('list', help='List all peers')
    
    trust_tier = peers_sub.add_parser('trust-tier', help='Set peer trust tier')
    trust_tier.add_argument('peer_id', help='Peer ID')
    trust_tier.add_argument('tier', choices=['core', 'sandbox', 'external', 'unknown'])
    
    # Crypto commands
    crypto = subparsers.add_parser('crypto', help='Cryptographic key management')
    crypto_sub = crypto.add_subparsers(dest='subcommand')
    
    keygen = crypto_sub.add_parser('keygen', help='Generate Ed25519 keypair')
    keygen.add_argument('--node-id', help='Node identifier (default: ark-primary)')
    keygen.add_argument('--force', action='store_true', help='Force regenerate if exists')
    
    crypto_sub.add_parser('list-keys', help='List all keys')
    
    export_key = crypto_sub.add_parser('export-key', help='Export public key')
    export_key.add_argument('--node-id', help='Node identifier (default: ark-primary)')
    
    import_key = crypto_sub.add_parser('import-key', help='Import peer public key')
    import_key.add_argument('peer_id', help='Peer node identifier')
    import_key.add_argument('public_key', help='Hex-encoded public key from peer')
    
    sign_test = crypto_sub.add_parser('sign-test', help='Test packet signing')
    sign_test.add_argument('--node-id', help='Node identifier (default: ark-primary)')
    
    crypto_sub.add_parser('self-test', help='Run crypto self-test')
    
    # Parse and execute
    args = parser.parse_args()
    
    if not args.command:
        print_banner()
        parser.print_help()
        return
    
    # Route to command
    command_map = {
        ('federation', 'start'): cmd_federation_start,
        ('federation', 'discover'): cmd_federation_discover,
        ('federation', 'add-peer'): cmd_federation_add_peer,
        ('federation', 'auto-sync'): cmd_federation_auto_sync,
        ('federation', 'status'): cmd_federation_status,
        ('peers', 'list'): cmd_peers_list,
        ('peers', 'trust-tier'): cmd_peers_trust_tier,
        ('crypto', 'keygen'): cmd_crypto_keygen,
        ('crypto', 'list-keys'): cmd_crypto_list_keys,
        ('crypto', 'export-key'): cmd_crypto_export_key,
        ('crypto', 'import-key'): cmd_crypto_import_key,
        ('crypto', 'sign-test'): cmd_crypto_sign_test,
        ('crypto', 'self-test'): cmd_crypto_self_test,
    }
    
    key = (args.command, args.subcommand) if hasattr(args, 'subcommand') else (args.command,)
    cmd_func = command_map.get(key)
    
    if cmd_func:
        asyncio.run(cmd_func(args))
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
