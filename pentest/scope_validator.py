#!/usr/bin/env python3
"""
ARK Penetration Testing Scope Validator
========================================

Validates targets against authorized scope definitions and enforces
legal/contractual boundaries for security testing activities.

This validator ensures that ARK only tests systems explicitly authorized
in signed scope documents, preventing unauthorized access and legal liability.

Legal Context:
- Computer Fraud and Abuse Act (CFAA) - USA
- Computer Misuse Act - UK
- Similar laws worldwide criminalize unauthorized access
- This validator is a critical control to prevent violations

Author: ARK Development Team
License: MIT
Version: 1.0.0
"""

import json
import hashlib
import ipaddress
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set, Any
from datetime import datetime, timezone
from dataclasses import dataclass
from enum import Enum
import fnmatch


class ValidationResult(Enum):
    """Validation result types"""
    ALLOWED = "allowed"
    DENIED = "denied"
    REQUIRES_APPROVAL = "requires_approval"
    BLACKOUT_PERIOD = "blackout_period"
    OUT_OF_SCOPE = "out_of_scope"
    EXPIRED = "expired"
    INVALID_SCOPE = "invalid_scope"


@dataclass
class ScopeValidation:
    """Result of scope validation check"""
    result: ValidationResult
    target: str
    target_type: str
    message: str
    scope_id: Optional[str] = None
    requires_approval: bool = False
    approval_type: Optional[str] = None
    matching_rule: Optional[str] = None
    timestamp: str = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for logging"""
        return {
            "result": self.result.value,
            "target": self.target,
            "target_type": self.target_type,
            "message": self.message,
            "scope_id": self.scope_id,
            "requires_approval": self.requires_approval,
            "approval_type": self.approval_type,
            "matching_rule": self.matching_rule,
            "timestamp": self.timestamp
        }


class ScopeValidator:
    """
    Validates targets against authorized penetration testing scope
    
    This class is a critical security control that enforces legal boundaries.
    It prevents ARK from accessing systems outside authorized scope, which
    could result in criminal prosecution under computer misuse laws.
    
    Key Features:
    - IP address and CIDR range validation
    - Hostname and wildcard domain matching
    - URL path validation
    - Time window enforcement
    - Blackout period detection
    - Automatic scope expiration
    - Cryptographic scope integrity verification
    """
    
    def __init__(self, scope_file: Path, audit_log: Optional[Path] = None):
        """
        Initialize validator with scope definition
        
        Args:
            scope_file: Path to scope.json file
            audit_log: Path to append-only audit log
        """
        self.scope_file = scope_file
        self.audit_log = audit_log or Path("data/pentest/logs/scope_validation.log")
        self.audit_log.parent.mkdir(parents=True, exist_ok=True)
        
        self.scope: Optional[Dict] = None
        self.scope_loaded = False
        self.scope_valid = False
        
        # Load and validate scope
        self._load_scope()
    
    def _load_scope(self) -> None:
        """Load and validate scope definition from file"""
        try:
            with open(self.scope_file, 'r') as f:
                self.scope = json.load(f)
            
            self.scope_loaded = True
            
            # Validate scope structure and integrity
            self._validate_scope_structure()
            self._verify_scope_integrity()
            self._check_scope_expiration()
            
            self.scope_valid = True
            
        except FileNotFoundError:
            self._log_validation(ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target="N/A",
                target_type="scope_file",
                message=f"Scope file not found: {self.scope_file}"
            ))
        except json.JSONDecodeError as e:
            self._log_validation(ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target="N/A",
                target_type="scope_file",
                message=f"Invalid JSON in scope file: {e}"
            ))
        except Exception as e:
            self._log_validation(ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target="N/A",
                target_type="scope_file",
                message=f"Error loading scope: {e}"
            ))
    
    def _validate_scope_structure(self) -> None:
        """Validate that scope has required fields"""
        required_fields = [
            "authorization_id",
            "version",
            "effective_date",
            "expiration_date",
            "in_scope",
            "out_of_scope",
            "time_windows",
            "allowed_methods"
        ]
        
        for field in required_fields:
            if field not in self.scope:
                raise ValueError(f"Missing required field in scope: {field}")
    
    def _verify_scope_integrity(self) -> None:
        """
        Verify cryptographic integrity of scope definition
        
        Calculates SHA-256 hash of in_scope object and compares with
        stored hash to detect tampering.
        """
        if "scope_hash" not in self.scope:
            # If no hash present, calculate and warn
            calculated_hash = self._calculate_scope_hash()
            print(f"‚ö†Ô∏è  WARNING: No scope_hash in scope file. Calculated hash: {calculated_hash}")
            print(f"‚ö†Ô∏è  Add this to scope.json: \"scope_hash\": \"{calculated_hash}\"")
            return
        
        calculated_hash = self._calculate_scope_hash()
        stored_hash = self.scope.get("scope_hash", "")
        
        if stored_hash == "PLACEHOLDER_HASH_TO_BE_CALCULATED_BY_VALIDATOR":
            # Placeholder detected - replace with actual hash
            print(f"üìù Calculating scope hash: {calculated_hash}")
            print(f"üìù Update scope.json with: \"scope_hash\": \"{calculated_hash}\"")
            return
        
        if calculated_hash != stored_hash:
            raise ValueError(
                f"Scope integrity check FAILED!\n"
                f"Stored hash:     {stored_hash}\n"
                f"Calculated hash: {calculated_hash}\n"
                f"Scope may have been tampered with!"
            )
    
    def _calculate_scope_hash(self) -> str:
        """Calculate SHA-256 hash of in_scope object"""
        in_scope_json = json.dumps(
            self.scope.get("in_scope", {}),
            sort_keys=True,
            separators=(',', ':')
        )
        return hashlib.sha256(in_scope_json.encode()).hexdigest()
    
    def _check_scope_expiration(self) -> None:
        """Check if scope authorization has expired"""
        expiration_str = self.scope.get("expiration_date")
        if not expiration_str:
            raise ValueError("No expiration_date in scope")
        
        expiration = datetime.fromisoformat(expiration_str.replace('Z', '+00:00'))
        now = datetime.now(timezone.utc)
        
        if now > expiration:
            raise ValueError(
                f"Scope authorization EXPIRED!\n"
                f"Expiration: {expiration}\n"
                f"Current:    {now}\n"
                f"Renewal required before testing can continue."
            )
        
        # Warning if expiring soon (within 7 days)
        days_remaining = (expiration - now).days
        if days_remaining <= 7:
            print(f"‚ö†Ô∏è  WARNING: Scope expires in {days_remaining} days ({expiration.date()})")
    
    def validate_ip(self, ip_address: str) -> ScopeValidation:
        """
        Validate if IP address is in authorized scope
        
        Args:
            ip_address: IPv4 address to validate
            
        Returns:
            ScopeValidation result
        """
        if not self.scope_valid:
            return ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target=ip_address,
                target_type="ip",
                message="Scope file is invalid or not loaded"
            )
        
        try:
            target_ip = ipaddress.ip_address(ip_address)
        except ValueError:
            return ScopeValidation(
                result=ValidationResult.DENIED,
                target=ip_address,
                target_type="ip",
                message="Invalid IP address format"
            )
        
        # Check out-of-scope first (explicit deny)
        out_of_scope = self.scope.get("out_of_scope", {})
        
        # Check out-of-scope IPs
        for denied_ip in out_of_scope.get("ip_addresses", []):
            if self._ip_matches(target_ip, denied_ip):
                result = ScopeValidation(
                    result=ValidationResult.OUT_OF_SCOPE,
                    target=ip_address,
                    target_type="ip",
                    message=f"IP explicitly out of scope: {denied_ip}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"out_of_scope.ip_addresses: {denied_ip}"
                )
                self._log_validation(result)
                return result
        
        # Check out-of-scope ranges
        for ip_range in out_of_scope.get("ip_ranges", []):
            if self._ip_in_range(target_ip, ip_range.get("start"), ip_range.get("end")):
                result = ScopeValidation(
                    result=ValidationResult.OUT_OF_SCOPE,
                    target=ip_address,
                    target_type="ip",
                    message=f"IP in out-of-scope range: {ip_range.get('reason', 'No reason')}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"out_of_scope.ip_ranges: {ip_range.get('start')}-{ip_range.get('end')}"
                )
                self._log_validation(result)
                return result
        
        # Check in-scope (explicit allow)
        in_scope = self.scope.get("in_scope", {})
        
        # Check in-scope IPs and CIDR ranges
        for allowed_ip in in_scope.get("ip_addresses", []):
            if self._ip_matches(target_ip, allowed_ip):
                result = ScopeValidation(
                    result=ValidationResult.ALLOWED,
                    target=ip_address,
                    target_type="ip",
                    message=f"IP authorized in scope: {allowed_ip}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"in_scope.ip_addresses: {allowed_ip}"
                )
                self._log_validation(result)
                return result
        
        # Check in-scope ranges
        for ip_range in in_scope.get("ip_ranges", []):
            if self._ip_in_range(target_ip, ip_range.get("start"), ip_range.get("end")):
                result = ScopeValidation(
                    result=ValidationResult.ALLOWED,
                    target=ip_address,
                    target_type="ip",
                    message=f"IP in authorized range: {ip_range.get('description', 'No description')}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"in_scope.ip_ranges: {ip_range.get('start')}-{ip_range.get('end')}"
                )
                self._log_validation(result)
                return result
        
        # Not found in scope - deny by default
        result = ScopeValidation(
            result=ValidationResult.DENIED,
            target=ip_address,
            target_type="ip",
            message="IP not found in authorized scope (default deny)",
            scope_id=self.scope.get("authorization_id")
        )
        self._log_validation(result)
        return result
    
    def validate_hostname(self, hostname: str) -> ScopeValidation:
        """
        Validate if hostname is in authorized scope
        
        Args:
            hostname: Domain name to validate
            
        Returns:
            ScopeValidation result
        """
        if not self.scope_valid:
            return ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target=hostname,
                target_type="hostname",
                message="Scope file is invalid or not loaded"
            )
        
        hostname = hostname.lower().strip()
        
        # Check out-of-scope first
        out_of_scope = self.scope.get("out_of_scope", {})
        
        # Check exact hostname match
        if hostname in [h.lower() for h in out_of_scope.get("hostnames", [])]:
            result = ScopeValidation(
                result=ValidationResult.OUT_OF_SCOPE,
                target=hostname,
                target_type="hostname",
                message=f"Hostname explicitly out of scope",
                scope_id=self.scope.get("authorization_id"),
                matching_rule=f"out_of_scope.hostnames: {hostname}"
            )
            self._log_validation(result)
            return result
        
        # Check wildcard domains (out of scope)
        for wildcard in out_of_scope.get("wildcard_domains", []):
            if self._hostname_matches_wildcard(hostname, wildcard):
                result = ScopeValidation(
                    result=ValidationResult.OUT_OF_SCOPE,
                    target=hostname,
                    target_type="hostname",
                    message=f"Hostname matches out-of-scope wildcard: {wildcard}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"out_of_scope.wildcard_domains: {wildcard}"
                )
                self._log_validation(result)
                return result
        
        # Check in-scope
        in_scope = self.scope.get("in_scope", {})
        
        # Check exact hostname match
        if hostname in [h.lower() for h in in_scope.get("hostnames", [])]:
            result = ScopeValidation(
                result=ValidationResult.ALLOWED,
                target=hostname,
                target_type="hostname",
                message=f"Hostname authorized in scope",
                scope_id=self.scope.get("authorization_id"),
                matching_rule=f"in_scope.hostnames: {hostname}"
            )
            self._log_validation(result)
            return result
        
        # Check wildcard domains (in scope)
        for wildcard in in_scope.get("wildcard_domains", []):
            if self._hostname_matches_wildcard(hostname, wildcard):
                result = ScopeValidation(
                    result=ValidationResult.ALLOWED,
                    target=hostname,
                    target_type="hostname",
                    message=f"Hostname matches authorized wildcard: {wildcard}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"in_scope.wildcard_domains: {wildcard}"
                )
                self._log_validation(result)
                return result
        
        # Not found - deny
        result = ScopeValidation(
            result=ValidationResult.DENIED,
            target=hostname,
            target_type="hostname",
            message="Hostname not found in authorized scope (default deny)",
            scope_id=self.scope.get("authorization_id")
        )
        self._log_validation(result)
        return result
    
    def validate_url(self, url: str, method: str = "GET") -> ScopeValidation:
        """
        Validate if URL is in authorized scope
        
        Args:
            url: Full URL to validate
            method: HTTP method (GET, POST, etc.)
            
        Returns:
            ScopeValidation result
        """
        if not self.scope_valid:
            return ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target=url,
                target_type="url",
                message="Scope file is invalid or not loaded"
            )
        
        # Parse URL to get hostname
        import urllib.parse
        parsed = urllib.parse.urlparse(url)
        hostname = parsed.hostname or ""
        
        # First validate hostname
        hostname_validation = self.validate_hostname(hostname)
        if hostname_validation.result != ValidationResult.ALLOWED:
            # Return hostname validation result
            return ScopeValidation(
                result=hostname_validation.result,
                target=url,
                target_type="url",
                message=f"URL hostname validation failed: {hostname_validation.message}",
                scope_id=self.scope.get("authorization_id")
            )
        
        # Check specific URL patterns in scope
        in_scope = self.scope.get("in_scope", {})
        for url_entry in in_scope.get("urls", []):
            pattern = url_entry.get("url", "")
            allowed_methods = url_entry.get("methods", ["GET", "POST", "PUT", "DELETE", "PATCH"])
            
            if self._url_matches_pattern(url, pattern):
                # Check if method is allowed
                if method.upper() not in [m.upper() for m in allowed_methods]:
                    result = ScopeValidation(
                        result=ValidationResult.DENIED,
                        target=url,
                        target_type="url",
                        message=f"HTTP method {method} not allowed for this URL (allowed: {', '.join(allowed_methods)})",
                        scope_id=self.scope.get("authorization_id"),
                        matching_rule=f"in_scope.urls: {pattern} (method restriction)"
                    )
                    self._log_validation(result)
                    return result
                
                # URL and method are both allowed
                result = ScopeValidation(
                    result=ValidationResult.ALLOWED,
                    target=url,
                    target_type="url",
                    message=f"URL and method authorized: {url_entry.get('description', 'No description')}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"in_scope.urls: {pattern}"
                )
                self._log_validation(result)
                return result
        
        # URL pattern not found, but hostname is allowed - allow by default
        result = ScopeValidation(
            result=ValidationResult.ALLOWED,
            target=url,
            target_type="url",
            message=f"URL allowed (hostname authorized, no specific URL restrictions)",
            scope_id=self.scope.get("authorization_id"),
            matching_rule=f"in_scope.hostnames: {hostname}"
        )
        self._log_validation(result)
        return result
    
    def check_time_window(self, test_type: str = "low_impact") -> ScopeValidation:
        """
        Check if current time is within allowed testing window
        
        Args:
            test_type: "low_impact" or "high_impact"
            
        Returns:
            ScopeValidation result
        """
        if not self.scope_valid:
            return ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target="time_check",
                target_type="time_window",
                message="Scope file is invalid or not loaded"
            )
        
        now = datetime.now(timezone.utc)
        
        # Check blackout periods first
        time_windows = self.scope.get("time_windows", {})
        for blackout in time_windows.get("blackout_periods", []):
            start = datetime.fromisoformat(blackout.get("start").replace('Z', '+00:00'))
            end = datetime.fromisoformat(blackout.get("end").replace('Z', '+00:00'))
            
            if start <= now <= end:
                result = ScopeValidation(
                    result=ValidationResult.BLACKOUT_PERIOD,
                    target=f"{now.isoformat()}",
                    target_type="time_window",
                    message=f"Testing forbidden during blackout period: {blackout.get('reason', 'No reason')}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"blackout: {start.date()} to {end.date()}"
                )
                self._log_validation(result)
                return result
        
        # Check if current time is in allowed window
        window = time_windows.get(test_type, {})
        if not window:
            # No window defined - deny by default
            result = ScopeValidation(
                result=ValidationResult.DENIED,
                target=f"{now.isoformat()}",
                target_type="time_window",
                message=f"No time window defined for {test_type} testing",
                scope_id=self.scope.get("authorization_id")
            )
            self._log_validation(result)
            return result
        
        # Check day of week
        current_day = now.strftime("%A").lower()
        allowed_days = [d.lower() for d in window.get("days", [])]
        
        if current_day not in allowed_days:
            result = ScopeValidation(
                result=ValidationResult.DENIED,
                target=f"{now.isoformat()}",
                target_type="time_window",
                message=f"Testing not allowed on {current_day} (allowed days: {', '.join(allowed_days)})",
                scope_id=self.scope.get("authorization_id"),
                matching_rule=f"time_windows.{test_type}.days"
            )
            self._log_validation(result)
            return result
        
        # Check time of day (simplified - assumes UTC)
        # TODO: Convert to specified timezone
        current_time = now.strftime("%H:%M")
        start_time = window.get("start_time", "00:00")
        end_time = window.get("end_time", "23:59")
        
        if not (start_time <= current_time <= end_time):
            result = ScopeValidation(
                result=ValidationResult.DENIED,
                target=f"{now.isoformat()}",
                target_type="time_window",
                message=f"Testing not allowed at {current_time} (allowed: {start_time}-{end_time})",
                scope_id=self.scope.get("authorization_id"),
                matching_rule=f"time_windows.{test_type}.time_range"
            )
            self._log_validation(result)
            return result
        
        # Check if approval required for high impact
        if test_type == "high_impact" and window.get("approval_required", False):
            result = ScopeValidation(
                result=ValidationResult.REQUIRES_APPROVAL,
                target=f"{now.isoformat()}",
                target_type="time_window",
                message=f"High-impact testing requires explicit approval",
                scope_id=self.scope.get("authorization_id"),
                requires_approval=True,
                approval_type="high_impact_testing",
                matching_rule=f"time_windows.{test_type}.approval_required"
            )
            self._log_validation(result)
            return result
        
        # Time window is valid
        result = ScopeValidation(
            result=ValidationResult.ALLOWED,
            target=f"{now.isoformat()}",
            target_type="time_window",
            message=f"Current time within {test_type} testing window",
            scope_id=self.scope.get("authorization_id"),
            matching_rule=f"time_windows.{test_type}"
        )
        self._log_validation(result)
        return result
    
    def check_method_allowed(self, method: str) -> ScopeValidation:
        """
        Check if testing method is allowed
        
        Args:
            method: Testing method (e.g., "active_exploitation", "social_engineering")
            
        Returns:
            ScopeValidation result
        """
        if not self.scope_valid:
            return ScopeValidation(
                result=ValidationResult.INVALID_SCOPE,
                target=method,
                target_type="method",
                message="Scope file is invalid or not loaded"
            )
        
        allowed_methods = self.scope.get("allowed_methods", {})
        method_config = allowed_methods.get(method, {})
        
        if isinstance(method_config, bool):
            # Simple boolean enable/disable
            if method_config:
                result = ScopeValidation(
                    result=ValidationResult.ALLOWED,
                    target=method,
                    target_type="method",
                    message=f"Testing method authorized: {method}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"allowed_methods.{method}"
                )
            else:
                result = ScopeValidation(
                    result=ValidationResult.DENIED,
                    target=method,
                    target_type="method",
                    message=f"Testing method not authorized: {method}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"allowed_methods.{method}"
                )
            self._log_validation(result)
            return result
        
        elif isinstance(method_config, dict):
            # Complex configuration
            if not method_config.get("enabled", False):
                result = ScopeValidation(
                    result=ValidationResult.DENIED,
                    target=method,
                    target_type="method",
                    message=f"Testing method disabled: {method}",
                    scope_id=self.scope.get("authorization_id"),
                    matching_rule=f"allowed_methods.{method}.enabled"
                )
                self._log_validation(result)
                return result
            
            # Check if approval required
            if method_config.get("requires_approval", False):
                result = ScopeValidation(
                    result=ValidationResult.REQUIRES_APPROVAL,
                    target=method,
                    target_type="method",
                    message=f"Testing method requires explicit approval: {method}",
                    scope_id=self.scope.get("authorization_id"),
                    requires_approval=True,
                    approval_type=method,
                    matching_rule=f"allowed_methods.{method}.requires_approval"
                )
                self._log_validation(result)
                return result
            
            # Method enabled and no approval required
            result = ScopeValidation(
                result=ValidationResult.ALLOWED,
                target=method,
                target_type="method",
                message=f"Testing method authorized: {method}",
                scope_id=self.scope.get("authorization_id"),
                matching_rule=f"allowed_methods.{method}"
            )
            self._log_validation(result)
            return result
        
        else:
            # Method not found in config - deny by default
            result = ScopeValidation(
                result=ValidationResult.DENIED,
                target=method,
                target_type="method",
                message=f"Testing method not defined in scope: {method}",
                scope_id=self.scope.get("authorization_id")
            )
            self._log_validation(result)
            return result
    
    # ========================================================================
    # Helper Methods
    # ========================================================================
    
    def _ip_matches(self, target_ip: ipaddress.IPv4Address, pattern: str) -> bool:
        """Check if IP matches pattern (single IP or CIDR)"""
        try:
            if '/' in pattern:
                # CIDR range
                network = ipaddress.ip_network(pattern, strict=False)
                return target_ip in network
            else:
                # Single IP
                pattern_ip = ipaddress.ip_address(pattern)
                return target_ip == pattern_ip
        except ValueError:
            return False
    
    def _ip_in_range(self, target_ip: ipaddress.IPv4Address, start: str, end: str) -> bool:
        """Check if IP is in range (start-end)"""
        try:
            start_ip = ipaddress.ip_address(start)
            end_ip = ipaddress.ip_address(end)
            return start_ip <= target_ip <= end_ip
        except ValueError:
            return False
    
    def _hostname_matches_wildcard(self, hostname: str, wildcard: str) -> bool:
        """Check if hostname matches wildcard pattern (e.g., *.example.com)"""
        wildcard = wildcard.lower().strip()
        hostname = hostname.lower().strip()
        
        if wildcard.startswith('*.'):
            # Wildcard subdomain match
            domain = wildcard[2:]  # Remove *.
            return hostname.endswith('.' + domain) or hostname == domain
        else:
            # Exact match
            return hostname == wildcard
    
    def _url_matches_pattern(self, url: str, pattern: str) -> bool:
        """Check if URL matches pattern (supports * wildcards)"""
        # Simple wildcard matching
        pattern = pattern.replace('*', '.*')  # Convert * to regex .*
        return bool(re.match(pattern, url))
    
    def _log_validation(self, validation: ScopeValidation) -> None:
        """Log validation result to append-only audit log"""
        try:
            log_entry = {
                "timestamp": validation.timestamp,
                "result": validation.result.value,
                "target": validation.target,
                "target_type": validation.target_type,
                "message": validation.message,
                "scope_id": validation.scope_id,
                "matching_rule": validation.matching_rule
            }
            
            with open(self.audit_log, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
        except Exception as e:
            print(f"‚ö†Ô∏è  WARNING: Failed to write audit log: {e}")
    
    def get_scope_summary(self) -> Dict:
        """Get human-readable summary of current scope"""
        if not self.scope_valid:
            return {"error": "Scope file is invalid or not loaded"}
        
        summary = {
            "authorization_id": self.scope.get("authorization_id"),
            "version": self.scope.get("version"),
            "effective_date": self.scope.get("effective_date"),
            "expiration_date": self.scope.get("expiration_date"),
            "status": "active",
            "in_scope_summary": {
                "ip_addresses": len(self.scope.get("in_scope", {}).get("ip_addresses", [])),
                "ip_ranges": len(self.scope.get("in_scope", {}).get("ip_ranges", [])),
                "hostnames": len(self.scope.get("in_scope", {}).get("hostnames", [])),
                "wildcard_domains": len(self.scope.get("in_scope", {}).get("wildcard_domains", [])),
                "urls": len(self.scope.get("in_scope", {}).get("urls", [])),
                "repositories": len(self.scope.get("in_scope", {}).get("repositories", [])),
                "containers": len(self.scope.get("in_scope", {}).get("containers", [])),
                "cloud_resources": len(self.scope.get("in_scope", {}).get("cloud_resources", [])),
            },
            "out_of_scope_summary": {
                "ip_addresses": len(self.scope.get("out_of_scope", {}).get("ip_addresses", [])),
                "ip_ranges": len(self.scope.get("out_of_scope", {}).get("ip_ranges", [])),
                "hostnames": len(self.scope.get("out_of_scope", {}).get("hostnames", [])),
                "wildcard_domains": len(self.scope.get("out_of_scope", {}).get("wildcard_domains", [])),
            }
        }
        
        return summary


def main():
    """Demonstration of scope validator"""
    print("=" * 80)
    print("ARK Scope Validator - Legal Boundary Enforcement")
    print("=" * 80)
    print()
    
    # Load scope file
    scope_file = Path("data/pentest/scope/scope_example.json")
    
    if not scope_file.exists():
        print(f"‚ùå Scope file not found: {scope_file}")
        print(f"   Create this file based on signed authorization before testing.")
        return
    
    validator = ScopeValidator(scope_file)
    
    if not validator.scope_valid:
        print("‚ùå Scope validation FAILED - cannot proceed with testing")
        return
    
    print("‚úÖ Scope loaded and validated")
    print()
    
    # Display scope summary
    summary = validator.get_scope_summary()
    print("üìã Scope Summary")
    print("-" * 80)
    print(f"Authorization ID: {summary['authorization_id']}")
    print(f"Version:          {summary['version']}")
    print(f"Effective:        {summary['effective_date']}")
    print(f"Expires:          {summary['expiration_date']}")
    print()
    print("In-Scope Assets:")
    for key, count in summary['in_scope_summary'].items():
        if count > 0:
            print(f"  - {key.replace('_', ' ').title()}: {count}")
    print()
    
    # Test validation examples
    print("üß™ Testing Validation Examples")
    print("-" * 80)
    
    test_cases = [
        ("ip", "192.168.1.100", "In-scope IP"),
        ("ip", "192.168.1.150", "In-scope IP (CIDR range)"),
        ("ip", "10.1.0.1", "Out-of-scope IP (corporate network)"),
        ("ip", "8.8.8.8", "Not in scope (deny by default)"),
        ("hostname", "test.example.com", "In-scope hostname"),
        ("hostname", "api-staging.example.com", "In-scope hostname"),
        ("hostname", "www.example.com", "Out-of-scope hostname"),
        ("hostname", "dev.staging.example.com", "Wildcard subdomain"),
        ("url", "https://api-staging.example.com/v1/users", "In-scope URL"),
        ("url", "https://www.example.com/admin", "Out-of-scope URL"),
        ("time", "low_impact", "Low-impact time window"),
        ("time", "high_impact", "High-impact time window (requires approval)"),
        ("method", "network_scanning", "Network scanning method"),
        ("method", "active_exploitation", "Active exploitation (requires approval)"),
        ("method", "social_engineering", "Social engineering (disabled)"),
    ]
    
    for test_type, target, description in test_cases:
        if test_type == "ip":
            result = validator.validate_ip(target)
        elif test_type == "hostname":
            result = validator.validate_hostname(target)
        elif test_type == "url":
            result = validator.validate_url(target)
        elif test_type == "time":
            result = validator.check_time_window(target)
        elif test_type == "method":
            result = validator.check_method_allowed(target)
        
        # Display result with color coding
        icon = "‚úÖ" if result.result == ValidationResult.ALLOWED else "‚ùå"
        if result.result == ValidationResult.REQUIRES_APPROVAL:
            icon = "‚ö†Ô∏è"
        
        print(f"{icon} {description}")
        print(f"   Target: {target}")
        print(f"   Result: {result.result.value.upper()}")
        print(f"   Message: {result.message}")
        if result.matching_rule:
            print(f"   Rule: {result.matching_rule}")
        print()
    
    print("=" * 80)
    print("Scope validation complete. Check audit log for full details:")
    print(f"  {validator.audit_log}")
    print("=" * 80)


if __name__ == "__main__":
    main()
